% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vap.R
\name{vap}
\alias{vap}
\alias{vapi}
\alias{vap2}
\alias{vap3}
\alias{vapp}
\alias{vap_vec}
\alias{vap_lgl}
\alias{vap_int}
\alias{vap_dbl}
\alias{vap_chr}
\alias{vap_raw}
\alias{vap_cpl}
\alias{vap_date}
\alias{vap_dttm}
\alias{vapi_lgl}
\alias{vapi_int}
\alias{vapi_dbl}
\alias{vapi_chr}
\alias{vapi_raw}
\alias{vapi_cpl}
\alias{vapi_date}
\alias{vapi_dttm}
\alias{vap2_lgl}
\alias{vap2_int}
\alias{vap2_dbl}
\alias{vap2_chr}
\alias{vap2_raw}
\alias{vap2_cpl}
\alias{vap2_date}
\alias{vap2_dttm}
\alias{vap3_lgl}
\alias{vap3_int}
\alias{vap3_dbl}
\alias{vap3_chr}
\alias{vap3_raw}
\alias{vap3_cpl}
\alias{vap3_date}
\alias{vap3_dttm}
\alias{vapp_lgl}
\alias{vapp_int}
\alias{vapp_dbl}
\alias{vapp_chr}
\alias{vapp_raw}
\alias{vapp_cpl}
\alias{vapp_date}
\alias{vapp_dttm}
\alias{with_vap_progress}
\alias{with_vap_handlers}
\title{Vector applies}
\usage{
vap(x, f, ...)

vapi(x, f, ...)

vap2(x, y, f, ...)

vap3(x, y, z, f, ...)

vapp(p, f, ...)

vap_vec(x, f, ...)

vap_lgl(x, f, ...)

vap_int(x, f, ...)

vap_dbl(x, f, ...)

vap_chr(x, f, ...)

vap_raw(x, f, ...)

vap_cpl(x, f, ...)

vap_date(x, f, ...)

vap_dttm(x, f, ...)

vapi_lgl(x, f, ...)

vapi_int(x, f, ...)

vapi_dbl(x, f, ...)

vapi_chr(x, f, ...)

vapi_raw(x, f, ...)

vapi_cpl(x, f, ...)

vapi_date(x, f, ...)

vapi_dttm(x, f, ...)

vap2_lgl(x, y, f, ...)

vap2_int(x, y, f, ...)

vap2_dbl(x, y, f, ...)

vap2_chr(x, y, f, ...)

vap2_raw(x, y, f, ...)

vap2_cpl(x, y, f, ...)

vap2_date(x, y, f, ...)

vap2_dttm(x, y, f, ...)

vap3_lgl(x, y, z, f, ...)

vap3_int(x, y, z, f, ...)

vap3_dbl(x, y, z, f, ...)

vap3_chr(x, y, z, f, ...)

vap3_raw(x, y, z, f, ...)

vap3_cpl(x, y, z, f, ...)

vap3_date(x, y, z, f, ...)

vap3_dttm(x, y, z, f, ...)

vapp_lgl(p, f, ...)

vapp_int(p, f, ...)

vapp_dbl(p, f, ...)

vapp_chr(p, f, ...)

vapp_raw(p, f, ...)

vapp_cpl(p, f, ...)

vapp_date(p, f, ...)

vapp_dttm(p, f, ...)

with_vap_progress(expr)

with_vap_handlers(expr)
}
\arguments{
\item{x, y, z}{Values to map over}

\item{f}{Function or specification of function to apply.}

\item{...}{Additional arguments passed to \code{f}}

\item{p}{A list of values (i.e., parameters) to map over}

\item{expr}{The expression to evaluate.}
}
\value{
For \code{\link[=vap]{vap()}}, \code{\link[=vapi]{vapi()}}, returns a \code{list} with length of \code{x}. For
\code{\link[=vap2]{vap2()}}, \code{\link[=vap3]{vap3()}}, and \code{\link[=vap]{vap()}}, return length is determined by how \code{...}
is recycled inside \code{\link[=mapply]{mapply()}}.

All have type variants (e.g., \code{\link[=vap_chr]{vap_chr()}}, \code{\link[=vapi_int]{vapi_int()}}, \code{\link[=vap3_dbl]{vap3_dbl()}})
which return a vector of the corresponding class, with the same length of
\code{x}, or following the same recycling rules as \code{\link[=mapply]{mapply()}} for multiple
inputs. These returns are \emph{coerced}, rather than \emph{checked}, and may result
in unexpected outputs. Likely, warnings or errors will be signaled
accordingly.

\code{\link[=vap_vec]{vap_vec()}} is a variant of \code{\link[=vap]{vap()}} that returns a \emph{flattened} vector. This
has similar behavior as \code{\link[base:lapply]{base::sapply()}}, in that a \code{list} will be returned
if the \code{\link[base:unlist]{base::unlist()}}'d output has multiple values in an element.

\code{\link[=with_vap_progress]{with_vap_progress()}} sets an option \code{vap.progress} to \code{TRUE} for the
duration of \code{expr}, which causes a progress bar to be displayed for any
\verb{vap*} calls inside \code{expr}.

\code{\link[=with_vap_handlers]{with_vap_handlers()}} sets an \code{options(vap.indexed_errors = TRUE)} for the
duration of \code{expr}, which causes errors inside \code{vap} calls to include the
index at which the error occurred.
}
\description{
Apply a function over elements of a \code{vector}.
}
\details{
Like \code{\link[=lapply]{lapply()}}, \code{\link[=mapply]{mapply()}}, and family, the \code{vap} functions provide
a means of applying a function to each element of a \code{vector}, and
controlling return types.  The \code{vap} family provides extra tools and
controls, as well as \emph{date} outputs (i.e., \verb{_date}, \verb{_dttm} variants that
work with \code{Date} and \code{POSIXct} types).
\itemize{
\item \code{vap()} uses a single \code{x} argument
\item \code{vapi()} uses a single \code{x} argument and passes the names (when available,
otherwise index) as the second argument
\item \code{vap2()}, \code{vap3()} use two and three arguments, respectively
\item \code{vapp()} uses a pairlist of arguments
}
}
\section{Extras}{
 Two helper functions are provided to set options for a
progress bars (\code{options(fuj.vap.progress)}) and reporting an index during
and error (\code{options(fuj.vap.index_error)}).  Two wrapper functions are
provided: \code{\link[=with_vap_progress]{with_vap_progress()}} and \code{\link[=with_vap_handlers]{with_vap_handlers()}}, respectively;
the latter may include other handlers in the future.  These are not turned
on by default (or rather, the option settings are set to \code{FALSE} within
\code{{fuj}}) as they incur some additional overhead.
}

\examples{
fruits <- c("apple", "banana", "pear")
vap(fruits, toupper)
vapi(fruits, function(x, i) paste0(i, ": ", toupper(x)))
vap_int(set_names(month.name, month.abb), nchar)
vap2_dbl(1:5, 6:10, `+`)
vapp_int(list(x = 1:5, y = 6:10, z = 11:15), sum)

# return type is coerced:
vap_int(1:5, paste0, "9")  # character -> integer
vap_date(month.name, nchar) # integer -> Date

# when f is a character or number, subsetting is performed
x <- list(list(a = 1, b = 3), list(a = 2, b = 4))
vap_int(x, "a")
vap_int(x, 2)

# wrap in [with_vap_progress()] to show a progress bar
invisible(
  with_vap_progress(
    vap(1:10 / 20, Sys.sleep)
  )
)

# wrap in [with_vap_handlers()] to report index on error
try(
  with_vap_handlers(
    vap(10:1, function(x) if (x == 3) stop("bad"))
  )
)
}
